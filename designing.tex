\section{Designing a robotics application}
\label{sec:designing}

In this section we first explain how to decompose a robotics
application in \diaspec{} component types. Then we present a case
study robotics application that we use as an example of how to
describe a robotics application with \diaspec{}.

In the rest of this paper we are going to take ROS
\footnote{\url{http://www.ros.org/wiki/}} as the underlying middleware
for our case study. We believe it is a good choice as ROS is becoming
a standard within the robotics community. It is important to note
however that our approach and \diaspec{} are completely independent of
any middleware.

\subsection{Decomposing}

Designing an application with \diaspec{} requires a decomposition in
layers. Each layer corresponds to a separate class of components:

\begin{itemize}
\item A \emph{sensor} sends information sensed from the environment to
  the context operator layer through data \emph{sources}. A sensor can
  both push data to context operators and respond to context operator
  requests. We use the term ``sensor'' both for entities that actively
  retrieve information from the environment, such as system probes,
  and entities that store information previously collected from the
  environment, such as structured information coming from the
  middleware.
\item A \emph{context operator} refines (aggregates and interprets)
  the information given by the sensors. Context operators can push
  data to other context operators and to control operators. Context
  operators can also respond to requests from parent context
  operators.
\item A \emph{control operator} transforms the information given by
  the context operators into orders for the actuators.
\item An \emph{actuator} triggers actions on the environment.
\end{itemize}

The following gives some guidelines to decompose a robotics
application into components.

\paragraph{Reusing existing components}
In the presence of a previous application developed with \diaspec{},
it is possible and advisable to reuse as much components as possible.
Depending on the amount of reused components, this can have a huge
impact on the application of the other guidelines.
% shouldn't talk about middleware reuse here as it is discussed below:
% It is similarly important to reuse as much building blocks as
% possible from the underlying middleware. For example ROS provides
% high-level components and algorithms that are better reused than
% reimplemented.

\paragraph{Listing capabilities}
Each robot comes with its own set of capabilities (\eg{} sensing
motion and projecting light). These capabilities should be mapped to
sensor sources and actuator actions. Related sources and actions
should then be grouped inside \emph{entity classes} (\eg{} a camera
providing a picture source and zooming action). Beside sources and
actions, an entity class may also have \emph{attributes} to
characterize its instances (\eg{} resolution, accuracy and status). In
the presence of a high-level middleware (such as ROS), it can be
useful to also map capabilities of the middleware into sources and
actions (\eg{} a mapping capability).

\paragraph{Identifying main context operators}
The next step of the decomposition in components is the identification
of the main high-level pieces of information required by the
application. These pieces of information are represented as context
operators. % and directly used as input to control operators

\paragraph{Decomposing into lower-level pieces}
Then, lower-level context operators must be identified to act as input
sources for the higher-level ones. This decomposition is typically
done in several steps, each step slightly lowering the level of
previously identified context operators. This decomposition ends when
each identified context operator can directly take its input from a
set of sensor sources. Additionally to the description of the input
sources, each context operator also describes a set of
\emph{interaction contracts} that coordinate these input sources. An
interaction contract is a tuple containing the following
information~\cite{Cass11a}: an \emph{activation condition} indicating
which input sources can activate the operator; a set of \emph{data
  requirements} indicating the additional input sources that can be
used for a particular activation condition; and a \emph{reaction}
indicating what to do as a result of the activation condition.

\paragraph{Identifying control operators}
From the high-level context operators, it is then necessary to derive
a set of control operators that are going to send orders to actuators
based on this information. Because the code of a control operator can
not be reused in another part of the application, it is important that
this code is as simple as possible. If there is opportunity for reuse,
the code should be moved to a new context operator. Similarly to a
context operator, a control operator contains a set of interaction
contracts.

\paragraph{Identifying data types}
While proceeding with the above steps, it is also necessary to define
various data types. These types are used to describe entity sources,
context operators, and parameters of actuator actions. A data type is
either primitive (\eg{} integer, boolean and float), an enumeration of
names (\eg{} a luminosity can either be low, normal or high), or a
structure (\eg{} a coordinate with x and y fields). An important
question arises in the presence of a high-level middleware
(such as ROS): should the types of the application be the types
provided by the middleware or should the application define
new types. The former solution is easier to use whereas the latter
provides more decoupling. A general principle is to provide new types
when their transcription in \diaspec{} is straightforward (\eg{} a
coordinate) and to reuse the middleware types otherwise (\eg{}
ROS defines a ``twist with covariance'' data type that is complex
enough to not be reimplemented).

\subsection{Case Study}

As a running example, we present an application that is typical of the
robotics domain. In this application, a robot evolves in an unknown
environment and has two modes: \emph{random} and \emph{discovery}. In
the random mode, the robot goes straight and when an obstacle is close
enough turns before going straight again. In the discovery mode, the
robot goes to unvisited locations with the goal to visit as much as
possible from the neighborhood. The mode can be changed anytime by an
operator through an administration graphical interface. In both modes,
the robot turns on an embedded projector and takes pictures when it is
in a zone with obstacles.

Let us now discuss the above guidelines in the context of this case
study.

\paragraph{Reusing existing components}
We assume no previous \diaspec{} application and thus no \diaspec{}
component to reuse.

\paragraph{Listing capabilities}
Our robot comes with a laser scan sensor, a light projector, a camera,
and a set of wheels. The ROS middleware comes with an
\emph{exploration} capability that is exactly what we need for the
robot's discovery mode. From all these capabilities, we identify:
\begin{itemize}
\item a laser scan entity with a \ct{ranges} source providing laser
  ranges from the sensor which can be deactivated when the robot is in
  discovery mode;\footnote{it is important to note that the
    application is not going to deactivate the hardware-level sensor
    (which is used in the two modes) but only the application-level
    source (which is only used in the random mode).}
\item a light projector entity that can be activated or deactivated on request;
\item a camera entity that takes pictures on request;
\item a wheels entity that can turn or rowl on request;
\item an exploration entity that provides a parametrized source of
  structured information;
\end{itemize}

\paragraph{Identifying main context operators}
Because the robot has two modes the application needs a context
operator which can tell which one is the current mode.



\subsection{Describing with \diaspec{}}

Once the application is decomposed using the different component types,
the transcription to the \diaspec{} design language is
straightforward. Listing~\ref{listing:design} gives the transcription
of the case study.

\lstinputlisting[float,language=diaspec,breakatwhitespace=true%
,caption={Description of the robotics application with the \diaspec{} language}%
,label={listing:design}]%
{code/design.diaspec}

In this listing, the keywords \ct{entity}, \ct{context},
\ct{controller}, and \ct{behavior} are respectively used to introduce
a new entity class, a new context operator, a new control operator,
and a new interaction contract. For this application, we decided to
reuse the \ct{Twist} and \ct{Image} data types of the ROS middleware
which is illustrated by the two \ct{import} lines.

%%% Local Variables:
%%% mode: latex
%%% coding: utf-8
%%% TeX-master: "dslrob"
%%% TeX-PDF-mode: t
%%% ispell-local-dictionary: "english"
%%% End:

% LocalWords:  boolean
